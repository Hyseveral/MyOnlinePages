
# HTTP/HTTPs
[参考](https://www.cnblogs.com/spll/p/10565189.html)

## HTTP(超文本传输协议):

- 最大的区别是http是用明文方式发送内容的，不要说什么get，post请求，post请求只是在浏览器上不显示参数，如果我们用一些抓包工具是一样会把http发送请求的内容给抓过来的。

- HHTP是无连接（一次只能处理一个请求，处理完就断开）、无状态的（对于事务处理没有记忆能力）。

- 使用80端口

- GET

    - 从指定的资源请求数据。请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的
    - 注释：
    
        
            GET 请求可被缓存
            GET 请求保留在浏览器历史记录中
            GET 请求可被收藏为书签
            GET 请求不应在处理敏感数据时使用
            GET 请求有长度限制
            GET 请求只应当用于取回数据（不修改）

- POST

    - 向指定的资源提交要被处理的数据
    - 用于将数据发送到服务器来创建/更新资源。通过 POST 发送到服务器的数据存储在 HTTP 请求的请求主体中:
        
        
            POST /test/demo_form.php HTTP/1.1
            Host: w3school.com.cn
            name1=value1&name2=value2
    
    
HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。


## HTTPs(安全套接字超文本传输协议):
- 在http协议的基础上加入了ssl协议+证书，用来加密传输数据
- ssl层协议：（全称：Secure Sockets Layer 安全套接层）是一种安全协议，SSL在传输层对网络连接进行加密
- 使用443接口


### 对称加密
客户端和服务端使用的是相同的秘钥。但是服务端需要与每一个客户端都维护一个秘钥，成本太高。
而且由于不同的客户端和服务端的安全级别不同，所以秘钥容易泄露。


### 非对称加密
客户端用公钥对请求内容加密，服务端用私钥进行解密后。处理后服务端用私钥进行加密，然后返回给客户端，
客户端再用公钥进行解密。

缺点：
公钥是公开的，所以黑客也会有公钥。但是他不能对客户端的信息进行解密，这点比较安全。
但是，对于服务端的返回内容，黑客可以用公钥进行解密，所以能够劫持服务端的信息。

### 二者结合
1. 客户端用 服务端的公钥 将 使用的对称加密算法和对称秘钥进行加密。此时黑客没有私钥所以无法解析。

2. 服务端收到信息后，使用私钥进行解密，提取出来对称加密算法和对称秘钥，然后返回信息用 这个对称秘钥进行加密。

3. 之后，客户端和服务端就有了临时的 对称秘钥和加密算法。二者之间使用这个进行安全通信，

问题：客户端如何获取公钥，以及确认服务端的身份不是黑客。
1. SSL证书（申购），即对话前，客户端提起访问请求后，服务端返回一个SSL证书。
证书中包含：证书的发布机构CA、证书的有效期、公钥、证书所有者、签名。

2. 客户端收到SSL证书以后，先查看证书的真假。
以浏览器为例，例如：


    1. 浏览器读取证书中的所有者、有效期进行校验
    2. 查找操作系统中内置的 受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发。
    3. 如果找不到，说明这个证书不可信任，报错。
    4. 如果找到，就取出CA的公钥，对证书里面的签名进行解密。
    使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比。
    对比结果一致，则证明服务器发来的证书合法，没有被冒充。
    5. 之后，浏览器就可以读取证书中的公钥，用于后续加密了





## HTTPS 原理详解
- [参考](https://zhuanlan.zhihu.com/p/27395037)



## 状态码
- 可参考[链接](https://www.runoob.com/http/http-status-codes.html)

200: 请求成功
301：资源（网页等）被永久的转移到其他URL
404：请求的资源不存在
500：内部服务器错误

### 状态码分类
1xx:信息，服务器收到请求，需要请求者继续执行操作
2xx:成功，操作被成功接收并处理
3xx:重定向，需要进一步的操作以完成请求
4xx:客户端错误，请求包含语法错误或无法完成请求
5xx:服务器错误，服务器在处理请求的过程中发生了错误

