
# TCP/IP五层模型
- [参考文章](https://www.cnblogs.com/qishui/p/5428938.html)
- [参考文章2](https://blog.csdn.net/zhang6223284/article/details/81414149)

## 什么是TCP/IP、UDP？
TCP/IP五层协议和OSI的七层协议对应关系: TCP/IP中应用层 对应 OSI 中的 应用层+表示层+运输层，其他为 传输层、网络层、数据链路层、物理层。


TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种

TCP/IP协议族包括应用层、运输层、网络层、链路层。

- 应用层

    - 功能：文件传输、电子邮件、文件服务、虚拟终端等
    - HTTP、FTP、SMTP、DNS、Telnet等

- 传输层
    
    - 功能：提供端到端的接口
    - TCP、UDP

- 网络层

    - 功能：为数据包选择路由
    - IP、ICMP、OSPF、BGP、IGMP、

- 数据链路层

    - 功能：传输有地址的帧以及错误检测


## TCP和UDP的区别
- TCP是面向连接的，UDP是面向无连接的
- UDP程序结构比较简单
- TCP是面向字节流的，UDP是基于数据包的
- TCP保证数据传输的正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证

***
## UDP
- 数据包头

        源端口号(16位)    目的端口号(16位)
        UDP长度(16位)     UDP校验和(16位)
                    数据

- UDP的特点

    - 沟通简单
    - 轻信他人，即它不会建立连接，但是会通过监听的方式，可以与任何人之间传输数据，可同时向多人传输数据
    - 不会变通，即不会根据网络的情况进程拥塞控制

- UDP的主要应用场景

    - 需要资源少，网络稳定的内网，或者对于丢包不敏感的应用，比如DHCP就是基于UDP协议的
    - 不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议
    - 需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前

- UDP的例子

    - 直播：直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议
    - 实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响
    - 物联网。一方面，物联网领域中断资源少，很可能只是个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的

***
## TCP

- TCP包头格式

    - 可见原文

- 包头中的内容分别有什么用

    - 源端口和目标端口是必不可少的
    - 包的序号：主要是为了解决乱序的问题
    - 确认序号：发出去的包需要有确认信息，才能知道对方是否收到，如果没有收到需要重新发送，即解决了不丢包的问题
    - 状态位：SYN是发起一个链接，ACK是回复确认信息，RST是重新连接，FIN是结束连接。由于TCP是面向连接的，所以需要双方维护连接的状态，而这些状态位的包会引起双方的状态变更
    - 窗口大小：TCP要做系统控制，需要通信双方各声明一个窗口，标识自己的当前处理能力

- TCP中重点关注的问题

    - 顺序问题
    - 丢包问题
    - 连接维护
    - 流量控制
    - 拥塞控制

### TCP三次握手
1. 刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态

2. 然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态

3. 客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了

4. 服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了。

## TCP四次挥手
- 图可参见原文

- 简单理解如下：

        A：B 啊，我不想玩了
        B：哦，你不想玩了啊，我知道了
        这个时候，只是 A 不想玩了，即不再发送数据，但是 B 可能还有未发送完的数据，所以需要等待 B 也主动关闭。
        B：A 啊，好吧，我也不玩了，拜拜
        A：好的，拜拜
    
1. 断开的时候，当 A 说不玩了，就进入 FIN_WAIT_1 的状态，B 收到 A 不玩了的消息后，进入 CLOSE_WAIT 的状态

2. A 收到 B 说知道了，就进入 FIN_WAIT_2 的状态，如果 B 直接跑路，则 A 永远处与这个状态。TCP 协议里面并没有对这个状态的处理，但 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间

3. 如果 B 没有跑路，A 接收到 B 的不玩了请求之后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是如果 B 没有接收到 A 跑路的 ACK 呢，就再也接收不到了，所以这时候 A 需要等待一段时间，因为如果 B 没接收到 A 的 ACK 的话会重新发送给 A，所以 A 的等待时间需要足够长

***
### 2.3 累计确认

### TCP 如何保证可靠传输

- 首先为了保证顺序性，每个包都有一个ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。

- 为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分

    - 发送并且确认的
    - 发送尚未确定的
    - 没有发送等待发送的
    - 没有发送并且暂时不会发送的

- 这里的第三部分和第四部分就属于流量控制的内容
- 在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了
    - 图可见原文

- 对于接收端来讲，它的缓存里面的内容要简单一些

    - 接收并且确认过的
    - 还没接收，但是马上要接收的
    - 还没接收，并且无法接收的

- 对应的数据结构如下
    - 图可见原文

***
## 2.4 顺序问题和丢包问题
- 结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。

- 在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。

- 发送端和接收端当前的状态如下：

    - 1、2、3 没有问题，双方达成了一致
    - 4、5 接收方说 ACK 了，但是发送方还没收到
    - 6、7、8、9 肯定都发了，但是 8、9 接收方已经收到了，6、7 没有收到(即8 9先到了)，出现了乱序，缓存着但是没办法 ACK。

- 根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。


**确认与重传机制**
- 假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？

- 一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。

- 如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。

- 当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。

- 超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？

- 有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。

- 例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。

***
## 2.5 流量控制的问题
- 在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小

- 简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了

***
## 2.6 拥塞控制的问题
- 也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往水管里灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。

- 水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。

- 如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。

- 图见原文：

- 如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。

- 如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端，它的缺点会增加时延，如果时延达到一定程度就会超时重传。

- TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。

- 具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来

- 慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。

- 拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。




