
# MySQL查询优化
- [参考链接1](https://blog.csdn.net/jack__frost/article/details/71512404)

搜索优化的整体思路：
索引优化，查询优化，查询缓存，服务器设置优化，操作系统和硬件优化，应用层面优化（web服务器，缓存）等等。对于一个整体项目而言只有这些齐头并进，才能实现mysql高性能。、


查询优化的因素思路：
1. 是否向数据库请求了不需要的数据。       

也就是说不要轻易使用select * from ，能明确多少数据就查多少个
    
2. mysql是否扫描额外的纪录
  
查询是否扫描了过多的数据。最简单的衡量查询开销三个指标如下：响应时间；扫描的行数；返回的行数。

> 响应时间：
>是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。 排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。—可能是等io操作完成，也可能是等待行锁，等等。
>
>扫描的行数和返回的行数:
>分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。
>
>扫描的行数和访问类型：
>在expain语句中的type列反应了访问类型。访问类型有很多种，从全表扫描（ALL）到索引扫描（index）到范围扫描（）到唯一索引查询到常数引用等。这里列的这些，速度由慢到快，扫描的行数也是从小到大。
>
>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：
>使用索引覆盖扫描。
改变库表结构。例如使用单独的汇总表。
重写这个复杂的查询。让mysql优化器能够以更优化的方式执行这个查询。
>

3. 查询方式：
一个复杂查询 or 多个简单查询
> 设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。

切分查询
> 有时候对于一个大查询我们需要“分而治之”，将大查询切分为小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。

分解关联查询
     
    select * from tag 
        join tag_post on tag_post.tag_id = tag.id
        join post on tag_post.post_id = post.id

    where tag.tag = 'mysql'

    可以分解成下面这些查询来代替：

    > select * from tag where tag = 'mysql'
    > select * from tag_post where tag_id = 1234
    > select * from post where post_id in (123, 456, 567, 9098, 8904)　　

让缓存的效率更高。

将查询分解后，执行单个查询可以减少锁的竞争。

在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。

查询本身效率也可能会有所提升。

可以减少冗余记录的查询，

更进一步，这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。
：https://blog.csdn.net/jack__frost/article/details/71512404