# Redis
- [参考文章](https://blog.csdn.net/Butterfly_resting/article/details/89668661)
## 单线程的redis为什么快
- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

## redis的过期策略以及内存淘汰机制
- redis采用的是定期删除+惰性删除策略。

- 为什么不用定时删除策略?

    定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.

- 定期删除+惰性删除是如何工作的呢?

    定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

    于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

- 采用定期删除+惰性删除就没其他问题了么?

    不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

- 在redis.conf中有一行配置: maxmemory-policy volatile-lru

- 该配置就是配内存淘汰策略的

    volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

    allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

    no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错

    ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。


## Redis 为什么是单线程的
- 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问
    
    1. 绝大部分请求是纯粹的内存操作（非常快速）
    2. 采用单线程,避免了不必要的上下文切换和竞争条件
    3. 非阻塞IO

- 优点

    1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
    2. 支持丰富数据类型，支持string，list，set，sorted set，hash
    3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
    4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题


## Redis操作是原子性的
- 对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。
- Redis的操作之所以是原子性的，是因为Redis是单线程的。
- Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。

## Redis事务
- Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的
- Redis会将一个事务中的所有命令序列化，然后按顺序执行。
    1. redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。

    2. 如果在一个事务中的命令出现错误，那么所有的命令都不会执行

    3. 如果在一个事务中出现运行错误，那么正确的命令会被执行。
    - 注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.

1. MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
2. EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 
3. 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
4. WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。