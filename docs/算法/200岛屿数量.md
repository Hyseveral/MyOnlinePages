# ledode 算法题

## 200. 岛屿数量

#### [原题链接点这里](https://leetcode-cn.com/problems/number-of-islands/)
>本题也是华为笔试第二题.....

### 题目：
> 难度：中等

    给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

    岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

    此外，你可以假设该网格的四条边均被水包围。


    示例 1:

    输入:
    [
    ['1','1','1','1','0'],
    ['1','1','0','1','0'],
    ['1','1','0','0','0'],
    ['0','0','0','0','0']
    ]
    输出: 1
    示例 2:

    输入:
    [
    ['1','1','0','0','0'],
    ['1','1','0','0','0'],
    ['0','0','1','0','0'],
    ['0','0','0','1','1']
    ]
    输出: 3
    解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。






### 代码如下：
> python3版本：

    class Solution:
        def numIslands(self, grid: List[List[str]]) -> int:

            # 华为笔试题目....

            # 方法一
            # DFS
            # 该题本质上是 进行深度优先搜索的次数
            # 搜索过的地方，注意标记！！

            # 方向数组，它表示了相对于当前位置的 4 个方向的横、纵坐标的偏移量，这是一个常见的技巧
            directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]

            if not grid:
                return 0
            
            m = len(grid)
            n = len(grid[0])
            # 统计深度搜索的次数，也就是岛屿的数量
            count = 0

            # 从该点开始深度优先搜索
            def dfs(i, j):
                # 首先 遍历过该点，那么标记，这里修改为 ‘0’
                grid[i][j] = '0'

                # 四个方向都要搜索
                for x, y in directions:
                    # 新的位置
                    i_new = i+x
                    j_new = j+y

                    # 如果这个位置符合要求，并且为‘1’,即可以访问，那么就递归访问
                    if 0 <= i+x <m and 0 <= j+y < n and grid[i_new][j_new] == '1':
                        dfs(i_new, j_new)



            # 遍历每一个位置，如果该位置被搜索过了，就标记
            # 这里我们直接在原来的 位置上进行标记，即访问过的陆地，标记为0.
            # 也可以用一个新的矩阵来标记是否已经访问过
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == '1':
                        count += 1
                        dfs(i, j)
            
            return count

        

        





