
# 守护进程
[原文链接](https://blog.csdn.net/woxiaohahaa/article/details/53487602)

## 概述
- Daemon程序是一直运行的服务端程序，又称为守护进程。通常在系统后台运行，没有控制终端不与前台交互，Daemon程序一般作为系统服务使用。

- Daemon是长时间运行的进程，通常在系统启动后就运行，在系统关闭时才结束。

- 一般说Daemon程序在后台运行，是因为它没有控制终端，无法和前台的用户交互。Daemon程序一般都作为服务程序使用，等待客户端程序与它通信。

- 它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的

- 常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

- 守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

- 守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。

- 守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。

- 守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？**之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。**  
由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，**当控制终端被关闭时，相应的进程都会自动关闭。**

## 守护进程的创建
- 首先我们需要理解一些基本概念：
    - 进程组(process group)： 一个或多个进程的集合，每个进程都有一个进程组ID，这个ID就是进程组长的进程ID

    - 会话期(session)： 一个或多个进程组的集合，每个会话有唯一一个会话首进程(session leader)，会话ID为会话首进程ID

    - 制终端(controlling terminal) ：每一个会话可以有一个单独的控制终端，与控制终端连接的会话首进程就是控制进程(controlling process)。 这时候，与当前终端交互的就是前台进程组，其他的都是后台进程组。


- 创建守护进程的过程中会用到一个关键函数：setsid()，这个函数用于创建一个新的会话期。

- 进程调用 setsid()函数会：
    - 首先请注意：**只有当该进程不是一个进程组长时，才会成功创建一个新的会话期。**

    1. 摆脱原会话的控制，该进程变成新会话期的首进程。

    2. 摆脱原进程组，成为一个新进程组的组长。

    3. 摆脱终端控制。如果在调用 setsid() 前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。

- 创建守护进程的的一般步骤：

    **1. fork()创建子进程，父进程exit()退出**

        这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。
    
    **2. 在子进程中调用 setsid() 函数创建新的会话**

        在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。
    
    **3. 再次 fork() 一个子进程并让父进程退出**

        现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程。

    **4. 在子进程中调用 chdir() 函数，让根目录 ”/” 成为子进程的工作目录**

        这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让"/"作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。
    
    **5. 在子进程中调用 umask() 函数，设置进程的文件权限掩码为0**

        文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为0，可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的使用方法为umask(0)。

    **6. 在子进程中关闭任何不需要的文件描述符**

        同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。  
        在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。

    **7. 守护进程退出处理**

        当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。



