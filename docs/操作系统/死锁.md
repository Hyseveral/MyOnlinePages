# 死锁

## 死锁产生的原因
- 死锁(deadlock)是指一组并发进程彼此相互等待对方所占有的资源，而这些进程在得到对方的资源之前不会释放自己所占有的资源，从而造成了这组进程都不能继续向前推进。

- 死锁产生的深层次原因就是对资源的竞争不当。

## 死锁产生的条件
- 四个条件

1. 互斥使用

    即一个资源一次只能由一个进程使用

2. 部分分配

    一个进程已经占有一定的资源，执行期间又再次申请其他资源

3. 不可抢占

    一个资源仅能由一个占有它的进程来释放，而不能被其他进程占有

4. 循环等待

    系统中存在一个由若干进程申请使用资源而形成的循环等待链，其中每一个进程占有若干个资源，同时又在等待其他进程占有的资源


## 死锁的处理方法

- 鸵鸟算法

    有请求就分配，允许死锁的发生，也就是不处理，或者等待人工处理

- 死锁预防

    - 破坏死锁产生的四个条件
    
        1. 破坏互斥使用，即允许多个进程同时访问一个资源
        2. 破坏部分分配，即一次性为进程分配所有的资源，即**静态分配策略**。该策略简单，但是严重降低了资源的利用率
        3. 破坏不可抢占，即强迫进程让出资源给其他进程使用
        4. 破坏循环等待，即使运行期间不存在任何进程循环等待现象

- 死锁避免

    - 为申请者分配资源前先测试系统的资源状况，如果把资源分配给申请者会出现死锁的话，那么就拒绝分配，否则才会为申请者分配资源

    - 死锁避免和死锁预防的区别

        - 死锁预防是破坏死锁的必要条件之一，使他不在系统中出现
        - 死锁避免是不那么严格地限制必要条件的出现，因为必要条件成立，也不一定会发生死锁。只有当检测到可能会发生死锁时，才执行该方法。从而提高系统的资源利用率
    
- 检测和恢复

    - 该方法对资源的分配不加以限制，但是系统需要不定时的运行一个“死锁检测”的程序，以此来判断是否出现死锁。
    - 如果出现了死锁，那么采取相应的方法接触死锁，并以尽可能小的代价恢复相应程序运行

    - 接触死锁的两种方式：一种是撤销进程法，二是剥夺资源法


## 活锁
定义：
如果事务T1封锁了数据对象R后，事务T2也请求封锁R，于是T2等待，接着T3也请求封锁R。
当T1释放了加载R上的锁后，系统首先批准T3的请求，T2只能继续等待。
接着T4也请求封锁R，T3释放R上的锁后，系统又批转了T4的请求。
这样的一直循环下去，事务T2就只能永远等待了，这样情况叫活锁。

解决方法：
采用先来先服务的队列策略。队列式申请。




